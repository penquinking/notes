<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chkkn notes</title>
  <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
  <a href="/">back</a>
  <div class="markdown-body">
    <h2>JavaScript</h2>
<pre class="hljs"><code># use console.log() to visualise variable or expression

function sum(a, b){
    console.log(a);
    console.log(a + b);
    return a + b;
}
sum(1,3);
</code></pre>
<pre class="hljs"><code># Must include return in js if not it will return undefined.

function sum(x,y){
    return x + y;
}

</code></pre>
<h3>String property</h3>
<pre class="hljs"><code>let text = &quot;Hello World&quot;;
text.length; // 11

# length does not have () because it's a property not method
</code></pre>
<pre class="hljs"><code>&quot;BLUE&quot;.toLowerCase(); // &quot;blue&quot;;
&quot;red&quot;.toUpperCase(); // &quot;RED&quot;;
</code></pre>
<h4>Characters</h4>
<pre class="hljs"><code>const language = &quot;JavaScript&quot;;

language[0]; // first character
language[1]; // second character
language[2]; // third character

language[language.length - 2]; // &quot;p&quot; because it's second to last character from &quot;JavaScript&quot;
</code></pre>
<pre class="hljs"><code># .at() reads character at certain index

const language = &quot;JavaScript&quot;;
language.at(0); // &quot;J&quot;
language.at(1); // &quot;a&quot;
language.at(-1); // &quot;t&quot;
language.at(-2); // &quot;p&quot;
</code></pre>
<h4>Substrings</h4>
<p>Substrings is a portion of a string e.g. rain in brain.</p>
<pre class="hljs"><code>const language = &quot;JavaScript&quot;;
language.substring(1,4); // &quot;ava&quot;

# indexEnd parameter is optional.
language.substring(4); //&quot;Script&quot;
</code></pre>
<p><code>.substr</code> is deprecated.</p>
<h4>Plus operator</h4>
<pre class="hljs"><code>&quot;Hello&quot; + &quot;World&quot; // &quot;HelloWorld&quot;
</code></pre>
<pre class="hljs"><code>let prefix = &quot;Mrs.&quot;;
let name = &quot;Sam&quot;;
let string = prefix + &quot; &quot; + name; // &quot;Mrs. Sam&quot;
</code></pre>
<pre class="hljs"><code>let name = &quot;Sam&quot;;
name = name + &quot; Blue&quot;;
console.log(name); // &quot;Sam Blue&quot;

# same as
name += &quot; Blue&quot;;
</code></pre>
<h4>Template strings</h4>
<p>Template strings support interpolation, means you can write variable in your string.</p>
<pre class="hljs"><code>`This is a template string`

# Multiline strings
let text = `This is a multiline
string that
just works!`
</code></pre>
<pre class="hljs"><code>let language = &quot;JavaScript&quot;;
`I am learning ${language}`;
</code></pre>
<h4>.trim()</h4>
<pre class="hljs"><code># Removes all leading and trailing space characters

const name = &quot;  Sam Blue &quot;;
name.trim(); // &quot;Sam Blue&quot;
</code></pre>
<h4>.startsWith() and .endsWith()</h4>
<pre class="hljs"><code># Return true when substring found at the beginning

const sentence = &quot;Hello there. Welcome!&quot;;

sentence.startsWith(&quot;H&quot;); // true
sentence.startsWith(&quot;Hello&quot;); // true
sentence.startsWith(&quot;Hey&quot;); // false
sentence.startsWith(&quot;Sam&quot;); // false

# Return true when substring found at the end

sentence.endsWith(&quot;.&quot;); // false
sentence.endsWith(&quot;!&quot;); // true
sentence.endsWith(&quot;Welcome!&quot;); // true
sentence.endsWith(&quot;Welcome&quot;); // false
</code></pre>
<h4>.includes(substring)</h4>
<pre class="hljs"><code># Return true when substring is found anywhere
const sentence = &quot;Hello there. Welcome!&quot;;

sentence.includes(&quot;there&quot;); // true
sentence.includes(&quot;W&quot;); // true
sentence.includes(&quot;Hello&quot;); // true
sentence.includes(&quot;Hey&quot;); // false
sentence.includes(&quot;Sam&quot;); // false
sentence.includes(&quot;.&quot;); // true
sentence.includes(&quot;!&quot;); // true
sentence.includes(&quot;Welcome&quot;); // true
</code></pre>
<h4>.split(separator)</h4>
<pre class="hljs"><code># Divide string into array by spliting with separator

let apps = &quot;Calculator,Phone,Contacts&quot;;
let appsArray = apps.split(&quot;,&quot;);
console.log(appsArray); // [&quot;Calculator&quot;, &quot;Phone&quot;, &quot;Contacts&quot;]
</code></pre>
<p>Note: opposite of <code>String.split(separator)</code> is <code>Array.join(glue)</code>.</p>
<h4>String.replace(search, replace)</h4>
<pre class="hljs"><code># The first occurence of `search` parameters is replaced with `replace` parameter.

const message = &quot;You are welcome.&quot;;
message.replace(&quot; &quot;, &quot;_&quot;); // &quot;You_are welcome.&quot;; (only the first occurrence has been replaced)
console.log(message); // &quot;You are welcome.&quot; (original string is not changed)
</code></pre>
<pre class="hljs"><code># Work the same as replace() but will replace all occurrences.

const message = &quot;You are welcome.&quot;;
message.replaceAll(&quot; &quot;, &quot;_&quot;); // &quot;You_are_welcome&quot;;
console.log(message); // &quot;You are welcome&quot; (original string is not changed)
</code></pre>
<h4>Slug</h4>
<p>A slug is a string used to identify a certain item.
E.g. <code>&quot;Easy assembly dining table&quot;</code> becomes <code>https://example.com/item/easy-assembly-dining-table</code></p>
<h3>Numbers</h3>
<pre class="hljs"><code>Example of numbers in JS
1
2
-5
3.5
2000
2021
-23.51
</code></pre>
<pre class="hljs"><code># Using numeric separator (_) makes it easier to read
let nb = 1_000; // equivalent to 1000
let nc = 1_000_000; // 1 million
</code></pre>
<pre class="hljs"><code># number to string
let answer = 42;
answer.toString();
</code></pre>
<h4>NaN</h4>
<p>Not a number.</p>
<pre class="hljs"><code>&quot;abc&quot; * 4; // NaN

# Sign something wrong with the code e.g. not converting string to a number
</code></pre>
<pre class="hljs"><code># Convert string to number
let str = &quot;42&quot;;
Number.parseInt(str, 10); //42

# Global objecet called Number which contains method parseInt
# Parameter 2 - radix: decimal 10, binary 2
</code></pre>
<p><code>parseInt()</code> works the same but use the modern <code>Number.parseInt</code></p>
<h4>Operations</h4>
<pre class="hljs"><code>8%2; // Devision remainder is 0
7%2 // Devision remainder is 1
</code></pre>
<pre class="hljs"><code>Math.round(2.6); // 3
Math.floor(2.6); // 2
Math.ceil(2.6); // 3

Math.round(2.5); // 3
Math.floor(2.5); // 2
Math.ceil(2.5); // 3
</code></pre>
<h3>Variables</h3>
<pre class="hljs"><code># let

let language = &quot;C++&quot;;
language = &quot;JavaScript&quot;;

let sum = 0;
sum += 1;
</code></pre>
<pre class="hljs"><code># const cannot be re-assigned

const language = &quot;C++&quot;;
language = &quot;Python&quot; // Type error
</code></pre>
<p>General rule is always go with <code>const</code> until you realised you need to re-assigned. <code>var</code> can still be used but its discourage to use.</p>
<h3>Conditions</h3>
<pre class="hljs"><code>const grade = 3;

if (grade &gt;= 10) {
    console.log(&quot;Passing grade&quot;);
} else {
    console.log(&quot;Failing grade&quot;);
}
</code></pre>
<pre class="hljs"><code>const grade = 10;

if (grade &gt; 10) {
    console.log(&quot;Passing grade&quot;);
} else if (grade === 10) {
    console.log(&quot;Passing on the limit&quot;);
} else {
    console.log(&quot;Failing grade&quot;);
}
</code></pre>
<h4>Ligatures</h4>
<p>This can be enabled on your code editor.</p>
<pre class="hljs"><code>&gt;= for &gt;=
&lt;= for &lt;=
=== for ===
!== for !==
</code></pre>
<h4>Advanced if</h4>
<pre class="hljs"><code># Dropping the else

function canVote(age) {
    if (age &gt;= 18) {
        return true;
    }
    return false;
}
</code></pre>
<p>Note: Use triple equal <code>===</code> instead of <code>==</code>. With <code>==</code> js will try to convert both values into the same data type.</p>
<h4>Returning booleans</h4>
<pre class="hljs"><code># Refactor boolean

function isPassing(grade) {
    return grade &gt;= 10;
}
</code></pre>
<h4>Even &amp; Odd</h4>
<pre class="hljs"><code>// even numbers
4 % 2 // 0
6 % 2 // 0
8 % 2 // 0
10 % 2 // 0

// odd numbers
3 % 2 // 1
5 % 2 // 1
7 % 2 // 1
9 % 2 // 1
</code></pre>
<h3>Arrays</h3>
<pre class="hljs"><code>const users = []; // empty array
const grades = [10, 8, 13, 15]; // array of numbers
const attendees = [&quot;Sam&quot;, &quot;Alex&quot;]; // array of strings
const values = [10, false, &quot;John&quot;]; // mixed
</code></pre>
<pre class="hljs"><code># .length property

[].length; // 0

const grades = [10, 8, 13, 15];
grades.length; // 4
</code></pre>
<pre class="hljs"><code># get element by index

const users = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charley&quot;];
users[1]; //&quot;Alex&quot;

# using .at(index)

const users = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charley&quot;];
users.at(1); //&quot;Alex&quot;
users.at(-2); //&quot;Alex&quot;
</code></pre>
<pre class="hljs"><code># adding a element

const numbers = [10, 8, 13, 15];
numbers.push(20); // returns 5 (the new length of the array)
console.log(numbers); // [10, 8, 13, 15, 20];
</code></pre>
<p>Even though the array is <code>const</code>, new data can still be pushed. This is because <code>const</code> means you can only assign variable once but doesn't mean the variable is immutable. Benefit to use <code>const</code> is the variable will always be an array.</p>
<pre class="hljs"><code>const numbers = []; // start with empty array
numbers.push(10); // returns 1 (new length of array)
console.log(numbers); // [10] (still an array but content changed)
numbers.push(20); // returns 2 (new length of array)
console.log(numbers); // [10, 20] (still an array but content changed)
</code></pre>
<h4>Array forEach</h4>
<pre class="hljs"><code># Looping through an array

const grades = [10, 8, 13];

grades.forEach(function(grade) {
    // do something with individual grade
    console.log(grade);
});
</code></pre>
<p><code>forEach</code> takes a callback function as an argument which is called once for each element in an array.
The callback function here it not actually executing the function but is defining how the function should behave if it's executed. The function definition is passed to <code>forEach</code> function. In this case <code>grade</code> is the function definition.</p>
<h4>Naming variables</h4>
<p>Use <strong>plural</strong> for <strong>array</strong> and <strong>singular</strong> for <strong>item</strong> of the array.<br>
E.g.</p>
<ul>
<li>grades =&gt; item is <strong>grade</strong></li>
<li>people =&gt; item is <strong>person</strong></li>
</ul>
<h4>Returning from loop</h4>
<p>In the function that calls <code>foreach</code> there are two 2 functions. The <code>return</code> should be outside the <code>foreach</code> function. Returning inside the function is not useful because it's going to return inside the callback function and <code>.foreach()</code> will always return <code>undefined</code>.</p>
<pre class="hljs"><code># Correct return

function logUserIds(userIds) {
    userIds.forEach(function(userId) {
        console.log(userId);
    });
    return true; // âœ… return from the logUserIds function
}
</code></pre>
<h4>Array filter</h4>
<pre class="hljs"><code># Returns another array with some items of the original array

const numbers = [9, 5, 14, 3, 11];

const numbersAboveTen = numbers.filter(function(number) {
    return number &gt; 10;
});
console.log(numbersAboveTen); // [14, 11]
</code></pre>
<p>The <code>.filter()</code> method expects a callback. JS takes the callback and call it for every singel item in the array.</p>
<h4>Array find</h4>
<pre class="hljs"><code>let names = [&quot;Sam&quot;, &quot;Alex&quot;, &quot;Charlie&quot;];

let result = names.find(function(name) {
  return name === &quot;Alex&quot;;
});
console.log(result); // &quot;Alex&quot;
</code></pre>
<p>The callback will stop calling once the array returns true.</p>
<h4>.filter() vs .find()</h4>
<ol>
<li><code>.filter()</code> always return an array.</li>
<li><code>.find()</code> returns first array item that matches.</li>
</ol>
<h4>Array map</h4>
<p><code>.map(callback)</code> <strong>transform</strong> an array into another.</p>
<pre class="hljs"><code>const numbers = [4, 2, 5, 8];

const doubled = numbers.map(function(number) {
    return number * 2;
});
console.log(doubled); // [8, 4, 10, 16]
</code></pre>
<p>It will be <code>[undefined, undefined].</code> if you forget <code>return</code> in the callback function.</p>
<h4>Array includes(item)</h4>
<p>Method takes an item <code>true</code> if the item exists.</p>
<pre class="hljs"><code>const groceries = [&quot;Apple&quot;, &quot;Peach&quot;, &quot;Tomato&quot;];

groceries.includes(&quot;Tomato&quot;); // true
groceries.includes(&quot;Bread&quot;); // false
</code></pre>
<h4>Array join(glue)</h4>
<p>Use glue to insert separators between items when converted to strings.</p>
<pre class="hljs"><code>const groceries = [&quot;Apple&quot;, &quot;Peach&quot;, &quot;Tomato&quot;];
groceries.join(&quot;; &quot;); // &quot;Apple; Peach; Tomato&quot;
groceries.join(&quot; . &quot;); // &quot;Apple . Peach . Tomato&quot;
</code></pre>
<h4>Array to string</h4>
<pre class="hljs"><code>const users = [{
    id: 1,
    name: &quot;Sam Doe&quot;
}, {
    id: 2,
    name: &quot;Alex Blue&quot;
}];

const userNamesArray = users.map(user =&gt; user.name);
console.log(userNamesArray); // [&quot;Sam Doe&quot;, &quot;Alex Blue&quot;];

const csv = userNamesArray.join(&quot;, &quot;);
console.log(csv); // &quot;Sam Doe, Alex Blue&quot;

# or

const csv = users.map(user =&gt; user.name).join(&quot;, &quot;);
console.log(csv); // &quot;Sam Doe, Alex Blue&quot;

</code></pre>
<pre class="hljs"><code># Applying to html

const html = `&lt;ul&gt;
    ${users.map(user =&gt; `&lt;li&gt;${user.name}&lt;/li&gt;`).join(&quot;&quot;)}
    &lt;/ul&gt;`;
console.log(html); // &lt;ul&gt; &lt;li&gt;Sam Doe&lt;/li&gt;&lt;li&gt;Alex Blue&lt;/li&gt; &lt;/ul&gt;
</code></pre>
<h4>Array.every(callback)</h4>
<pre class="hljs"><code># Return true when every number satisfy

const numbers = [15, 10, 20];

const allAbove10 = numbers.every(number =&gt; number &gt;= 10); // true
const allAbove15 = numbers.every(number =&gt; number &gt;= 15); // false
</code></pre>
<h4>Array.some(callback)</h4>
<pre class="hljs"><code># Return true whenn at least on item satisfies the condition
const numbers = [15, 10, 20];

const someOver18 = numbers.some(number =&gt; number &gt;= 18); // true
const someUnder10 = numbers.some(number =&gt; number &lt; 10); // false
</code></pre>
<h4>Deleting items</h4>
<pre class="hljs"><code># Set length to 0 to empty array
const items = [&quot;Pen&quot;, &quot;Paper&quot;];
items.length = 0;

console.log(items); // []
</code></pre>
<p>To delete specific items using splice.</p>
<ul>
<li>Delete first item <code>.splice(0, 1)</code>.</li>
<li>Delete 3 elements starting from the 2nd position <code>.splice(1, 3)</code>.</li>
<li><code>.splice(1)</code>remove all the items starting from the 2nd position.</li>
</ul>
<pre class="hljs"><code>const items = [&quot;Pen&quot;, &quot;Paper&quot;, &quot;Staples&quot;];
const deletedItem = items.splice(0, 1); // removes one element at index 0
console.log(deletedItem); // [&quot;Pen&quot;]

console.log(items); // [&quot;Paper&quot;, &quot;Staples&quot;]
</code></pre>
<h3>Array reduce</h3>
<p><code>reduce()</code> caculate a single value from an array it accepts a <strong>reducer</strong> which is a callback. Reduce is a generic function that will reduce an array into a single value.</p>
<h4>Reduce: sum</h4>
<pre class="hljs"><code># Total is the last computed value, called accumulator
# Current is the single item in the array

const sum = grades.reduce((total, current) =&gt; {
    return total + current;
}, 0);
</code></pre>
<p><code>.reducer()</code> accepts 2 parameters: <code>reducer</code> and <code>initialValue</code>. <code>initialValue</code> is the same as <code>let sum = 0</code>.</p>
<h4>Reduce: multiplication</h4>
<pre class="hljs"><code>const result = numbers.reduce((total, current) =&gt; {
    return total * current;
}, 1);
console.log(result); // 100
</code></pre>
<p>Starting value is <code>1</code> because multiplying by <code>0</code> will return <code>0</code>. <code>1</code> is neutral in multiplication.</p>
<h4>Common mistakes</h4>
<ul>
<li>Syntax errors</li>
<li>Forgetting to return</li>
<li>Wrong initialValue</li>
</ul>
<h3>Array destructing</h3>
<p>Array destructing is new to js, it considered <strong>syntactic sugar</strong>, meaning easy to read code. You can identify destructuring when you see the square brackets [] on the left side of the equal sign.</p>
<pre class="hljs"><code>const dimensions = [20, 5]

// create variables
const [width, height] = dimensions;

// log them
console.log(width); //20
console.log(height); //5
</code></pre>
<h3>Array concatenation</h3>
<pre class="hljs"><code># Concatenate/merge arrays' content using ...

const lat = [5.234];
const lng = [1.412];
const point = [...lat, ...lng];
console.log(point); // [5.234, 1.412];
</code></pre>
<pre class="hljs"><code>const items = [&quot;Tissues&quot;, &quot;Oranges&quot;];

const otherItems = [...items, &quot;Tomatoes&quot;];
console.log(otherItems); // [&quot;Tissues&quot;, &quot;Oranges&quot;, &quot;Tomatoes&quot;]
</code></pre>
<h3>Objects</h3>
<p>An object is a data type that allows you to group several variables together into one variable that contains keys and values.</p>
<pre class="hljs"><code>const user = {
    id: 1,
    firstName: &quot;Sam&quot;,
    lastName: &quot;Doe&quot;,
    age: 20
};

user.id; // 1
user.firstName; // &quot;Sam&quot;
user.isAdmin; // undefined (property does not exist)

# Updating the property value
user.age = user.age + 1;


</code></pre>
<h4>Dynamic property</h4>
<p><strong>Dot syntax</strong> does not work on property that is stored as variable or result of an expression (dynamic).
<code>Object.keys(obj)</code> returns an array of keys.</p>
<pre class="hljs"><code>const settings = {
    theme: &quot;Dark&quot;,
    version: &quot;2.4.1&quot;,
    beta: false
};

const keys = Object.keys(settings);
console.log(keys); // [&quot;theme&quot;, &quot;version&quot;, &quot;beta&quot;]
keys.forEach(key =&gt; {
    // log the value of every key dynamically
    console.log(settings[key]);
});

</code></pre>
<pre class="hljs"><code>const getUpperCasedProperties = course =&gt; {
    return Object.keys(course).map(key =&gt; key.toUpperCase());
}
</code></pre>
<pre class="hljs"><code>export const getTranslation = (language) =&gt; {
    return translations.welcome[language];
}
</code></pre>
<h3>Arrow functions</h3>
<h4>Default parameters</h4>
<p>In Js if an argument is not passed in the function parameters the code will not fail but instead passed as <code>undefined</code>.</p>
<pre class="hljs"><code>function addOne(number = 0) {
    return number + 1;
}

addOne(2); // 3
addOne(5); // 6
addOne(); // 1

# When calling the function without an argument the default value is set to 0.
</code></pre>
<h4>Function to arrow functions</h4>
<p>Benefits of arrow function:</p>
<ol>
<li>Shorter to write.</li>
<li>Uses lexical scope.</li>
<li>Benefit from implicit return.</li>
</ol>
<pre class="hljs"><code>function sum(a, b) {
    return a + b;
}

const sum = function(a, b) {
    return a + b;
}

const sum = (a, b) =&gt; {
    return a + b;
}
</code></pre>
<p>Functions are not deprecated. You can use functions but arrow functions is preferred because of their benefits.</p>
<h4>Arrow function forEach</h4>
<pre class="hljs"><code>grades.forEach((grade) =&gt; {
    console.log(grade);
});

# if it's one parameter you can drop ()
grades.forEach(grade =&gt; {
    console.log(grade);
});
</code></pre>
<h4>Arrow function array filter()</h4>
<pre class="hljs"><code>const numbersAboveTen = numbers.filter((number) =&gt; {
    return number &gt; 10;
});
</code></pre>
<h3>Implicit return</h3>
<p>When you forget to write <code>return</code> you'll get an implicit <code>return undefined</code>. Implicit it means it is refer to something suggested or understood without directly stating.</p>
<p>In JS under specific conditions, implicit return will work:</p>
<ol>
<li>Must be an arrow function.</li>
<li>Function body must be <strong>one statement</strong>. Curly braces can be removed.</li>
<li><code>Return</code> must be removed because its one statement.</li>
</ol>
<pre class="hljs"><code>const isLegal = (age) =&gt; {
    return age &gt;= 18;
}

# Removing curly brackets &amp; return

const isLegal = (age) =&gt; age &gt;= 18;

# Removing parentheses

const isLegal = age =&gt; age &gt;= 18;
</code></pre>
<h4>Array filter(callback)</h4>
<pre class="hljs"><code>const numbersAboveTen = numbers.filter(number =&gt; number &gt; 10);

const getPositiveTemperatures = temperatures =&gt; {
    return temperatures.filter(temperature  =&gt; temperature &gt; 0);
}
</code></pre>
<h4>Array find(callback)</h4>
<pre class="hljs"><code>const result = names.find(name =&gt; name === &quot;Alex&quot;);
</code></pre>
<h4>Array map(callback)</h4>
<pre class="hljs"><code>const doubled = numbers.map(number =&gt; number * 2);
</code></pre>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
